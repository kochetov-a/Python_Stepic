### Символы и строки

`genome = 'ATGG'`

----
`genome[0]` A - первый символ

`genome[1]` T - второй символ

`genome[2]` G - третий символ

`genome[3]` G - четвертый символ

----
`genome[-1]` G - первый символ с конца

`genome[-2]` G - второй символ с конца

`genome[-3]` T - третий символ с конца

`genome[-4]` A - четвертый символ с конца

----

```python
# Перечсление символов строки с помощью индексов
genome = 'ATGG'

for i in range(4):
    print(genome[i])
```

```python
genome = 'ATGG'

for i in genome: # переменная принимает все значения из genome
    print(i)
```

```python
# Посчитать сколько раз встречается цитозин (С)
# Решение 1

genome = input()
cnt = 0 # счётчик

for nucl in genome: # перебираем символы
    if nucl == 'C': # сравниваем с С
        cnt += 1 # если совпадает, увеличиваем счётчик
print(cnt)
```

```python
# Посчитать сколько раз встречается цитозин (С)
# Решение 2
genome = input()
print(genome.count("C")) # функция считает сколько раз встречается искомый символ
```

### Методы строк
**Входные данные**
- s = 'aTGcc'
- p = 'cc'

#### Методы
* `s.upper` - заменяет все маленькие символы, на большие - `'ATGCC'`
* `s.lower` - заменяет все большие символы, на маленькие - `'atgcc'`
* `s.count(p)` - сколько раз `р` встречается в `s` - `1`
* `s.find(p)` - первое вхождение (индекс) `p` в `s` - `3`
* `s.find('A')` - первое вхождение (индекс) `p` в `s` - `-1` (строка 'A' не входит в `s`)
* `s.replace('c', 'C')` - заменяем все вхождения 'c' на 'C' - `'aTGCC'`

#### Задание
GC-состав является важной характеристикой геномных последовательностей и определяется как процентное соотношение суммы всех гуанинов и цитозинов к общему числу нуклеиновых оснований в геномной последовательности. 

Напишите программу, которая вычисляет процентное содержание символов G (гуанин) и C (цитозин) в введенной строке (программа не должна зависеть от регистра вводимых символов).

Например, в строке `"acggtgttat"` процентное содержание символов G и C равно `4 / 10 * 100 = 40.0`, где `4` -- это количество символов `G` и `C`,  а `10` -- это длина строки.

```python
g = input().upper()
print(((g.count('C') + g.count('G')) / len(g)) * 100)
```

### Slicing
* `dna = 'ATTCGGAGCT'`
* `dna[1]` - T (берем символ в позиции 1)
* `dna[1:4]` - TTC (берем символы с 1 по 4)
* `dna[:4]` - ATTC (берем символы с позиции 0 и до позиции 4)
* `dna[4:]` - GGAGCT (от 4-го символа и до конца строки)
* `dna[-4:]` - AGCT (берем 4-й символ с конца и до конца строки)
* `dna[1:-1]` - TTCGGAGC (не включаем последний символ строки)
* `dna[1:-1:2]` - TCGG (перебор символов с шагом в 2 символа + не берем последний)
* `dna[::-1]` - TCGAGGCTTA (символы в обратном порядке)

```python
# Является ли строка полиндромом (одинаково читается слева направо и справа налево)
# Решение №1

s = input().upper()
i = 0 # символ слева
j = len(s) - 1 # символ справа
is_palindrom = True

while i < j:
    if s[i] != s[j]: # сравниваем символы с начала и с конца
        is_palindrom = False # если символы не совпадают, меняем значение переменной
        break
    i += 1 # сдвигаемся на один символ вправо
    j -= 1 # сдвигаемся на один символ влево
if is_palindrom: # после окончания цикла while проверяем значение переменной
    print("YES") # если она true - то слово является палиндромом
else:
    print("NO") # если она False - то слово не является палиндромом
```

```python
# Является ли строка полиндромом (одинаково читается слева направо и справа налево)
# Решение №1

s = input().upper()
r = s[::-1]
if s == r:
    print("YES")
else:
    print("NO")
```

#### Задание
Узнав, что ДНК не является случайной строкой, только что поступившие в Институт биоинформатики студенты группы информатиков предложили использовать алгоритм сжатия, который сжимает повторяющиеся символы в строке.

Кодирование осуществляется следующим образом:
`s = 'aaaabbсaa'` преобразуется в `'a4b2с1a2'`, то есть группы одинаковых символов исходной строки заменяются на этот символ и количество его повторений в этой позиции строки.

Напишите программу, которая считывает строку, кодирует её предложенным алгоритмом и выводит закодированную последовательность на стандартный вывод. Кодирование должно учитывать регистр символов.

```python
# Решение №1
gen = input()
n = 0
i = 0
s = ''

# защита от случая когда строка из одного символа
if len(gen) > 2:
    s1 = gen[i]
    s2 = gen[i + 1]
else:
    s1 = gen[i]
    s2 = s1

while i <= len(gen):
    if s1 == s2:
        n += 1
        s += s2
    else:
        print(s[0:1], end="")
        if n > 0:
            print(n, end="")
        s = s1
        n = 1
    if i < len(gen) - 1:
        i += 1
        s2 = s1
        s1 = gen[i]
    else:
        print(s[0:1], end="")
        print(n, end="")
        break
```

```python
# Решение №2

gen = input()
gen += "1"
n = gen[0]
r = 0

for i in gen:
    if n != i:
        print(n, r, sep="", end="")
        r = 0
    n = i
    r += 1
```